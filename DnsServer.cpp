#include "DnsServer.h"#include <algorithm>#include <iostream>#include <stdexcept>using namespace boost::asio;SimpleDNSLogger::DnsServer::DnsServer()	: ioService(), socket(ioService){}SimpleDNSLogger::DnsServer::~DnsServer(){	Stop();}void SimpleDNSLogger::DnsServer::SetListenPort(const std::string& address, unsigned short port){	socket = ip::udp::socket(ioService);	socket.open(ip::udp::v4());	socket.bind(ip::udp::endpoint(ip::address::from_string(address), port));}void SimpleDNSLogger::DnsServer::SetCallback(Callback&& procedure){	callback = std::move(procedure);}void SimpleDNSLogger::DnsServer::Run(bool block){	WaitForSingleRequest();	worker = std::thread([this]()	{		while (true)		{			try			{				ioService.run();				break;			}			catch (std::exception& e)			{				std::cerr << "dns_server: run(): unexpected exception: " << e.what() << '\n';			}			catch (...)			{				std::cerr << "dns_server: run(): unexpected exception";			}		}	});	if (block && worker.joinable())		worker.join();}void SimpleDNSLogger::DnsServer::Stop(){	ioService.stop();	if (worker.joinable())		worker.join();}void SimpleDNSLogger::DnsServer::WaitForSingleRequest(){	auto transaction = std::make_unique<Transaction>(*this);	transaction->WaitForSingleRequest(std::move(transaction));}SimpleDNSLogger::DnsServer::Transaction::Transaction(DnsServer& server)	: server(server){	// std::cout << "Transaction: New: " << this << '\n';}SimpleDNSLogger::DnsServer::Transaction::~Transaction(){	// std::cout << "Transaction: Delete: " << this << '\n';}void SimpleDNSLogger::DnsServer::Transaction::WaitForSingleRequest(std::unique_ptr<Transaction>&& self){	server.socket.async_receive_from(mutable_buffer(buffer.data(), buffer.size()), peerEndpoint,	                                 [this, self = std::move(self)](boost::system::error_code code,	                                                                size_t transferred)mutable	                                 {		                                 server.WaitForSingleRequest();		                                 if (code.failed())		                                 {			                                 return;		                                 }		                                 RequestHandler(std::move(self), transferred);	                                 });}void SimpleDNSLogger::DnsServer::Transaction::RequestHandler(std::unique_ptr<Transaction>&& self, size_t transferred){	DnsPacket packet;	std::string from = self->peerEndpoint.address().to_string();	try	{		packet.FromBuffer(buffer.data(), transferred);		// std::cout << "DNS Packet: TransactionId: " << packet.id << '\n';	}	catch (...) { return; } // bad packet	for (auto& q : packet.queries)	{		std::string name;		for (auto& l : q.qName)		{			name += l;			name += '.';		}		if (name.empty())			name += '.';		std::cerr << "DNS Request: " << name << " from: " << from << '\n';		if (server.callback)			server.callback(name, from);	}	packet.answers.clear();	packet.authorities.clear();	packet.additions.clear();	try	{		// prepare reply		// bad request		if (packet.GetFlag<DnsPacket::FLAG_OPCODE>() != DnsPacket::FLAG_OPCODE::Query)		{			packet.flags &= 0b0'1111'0'0'1'0'0'0'0'0000;			packet.SetFlag<DnsPacket::FLAG_QR>(1);			packet.SetFlag<DnsPacket::FLAG_AA>(1);			packet.SetFlag<DnsPacket::FLAG_RCODE>(DnsPacket::FLAG_RCODE::ServFail);			packet.queries.clear();		}		else		{			packet.answers.clear();			packet.authorities.clear();			packet.additions.clear();			packet.flags &= 0b0'1111'0'0'1'0'0'0'0'0000;			packet.SetFlag<DnsPacket::FLAG_QR>(1);			packet.SetFlag<DnsPacket::FLAG_AA>(1);			packet.SetFlag<DnsPacket::FLAG_RCODE>(DnsPacket::FLAG_RCODE::NoError);		}		replyLength = packet.ToBuffer(buffer.data(), buffer.size());		SendReply(std::move(self));	}	catch (...) { return; }}void SimpleDNSLogger::DnsServer::Transaction::SendReply(std::unique_ptr<Transaction>&& self){	server.socket.async_send_to(const_buffer(buffer.data(), replyLength), peerEndpoint,	                            [self = std::move(self)](boost::system::error_code code,	                                                     size_t transferred)	                            {	                            });}void SimpleDNSLogger::DnsPacket::FromBuffer(const char* buffer, size_t size){	PacketReader reader(buffer, size);	id = reader.ReadUInt16();	flags = reader.ReadUInt16();	const auto queryCount = reader.ReadUInt16();	const auto answerCount = reader.ReadUInt16();	const auto authorityCount = reader.ReadUInt16();	const auto additionalCount = reader.ReadUInt16();	ReadQueries(reader, queryCount, queries);	ReadRecords(reader, answerCount, answers);	ReadRecords(reader, authorityCount, authorities);	ReadRecords(reader, additionalCount, additions);}size_t SimpleDNSLogger::DnsPacket::ToBuffer(char* buffer, size_t size) const{	PacketWriter writer(buffer, size);	writer.WriteUInt16(id);	writer.WriteUInt16(flags);	writer.WriteUInt16(queries.size());	writer.WriteUInt16(answers.size());	writer.WriteUInt16(authorities.size());	writer.WriteUInt16(additions.size());	WriteQueries(writer, queries);	WriteRecords(writer, answers);	WriteRecords(writer, authorities);	WriteRecords(writer, additions);	return writer.GetPos();}void SimpleDNSLogger::DnsPacket::ReadQueries(PacketReader& reader, size_t n, std::vector<Query>& out){	out.clear();	for (size_t i = 0; i < n; ++i)	{		Query query;		reader.ReadLabels(query.qName);		query.qType = reader.ReadUInt16();		query.qClass = reader.ReadUInt16();		out.emplace_back(std::move(query));	}}void SimpleDNSLogger::DnsPacket::ReadRecords(PacketReader& reader, size_t n, std::vector<Record>& out){	out.clear();	for (size_t i = 0; i < n; ++i)	{		Record record;		reader.ReadLabels(record.rName);		record.rType = reader.ReadUInt16();		record.rClass = reader.ReadUInt16();		record.rTTL = reader.ReadUInt32();		record.rDataLength = reader.ReadUInt16();		const auto start = reader.ReadByteArray(record.rDataLength);		const auto end = start + record.rDataLength;		record.rData.assign(start, end);		out.emplace_back(std::move(record));	}}void SimpleDNSLogger::DnsPacket::WriteQueries(PacketWriter& writer, const std::vector<Query>& in){	for (auto& q : in)	{		writer.WriteLabels(q.qName);		writer.WriteUInt16(q.qType);		writer.WriteUInt16(q.qClass);	}}void SimpleDNSLogger::DnsPacket::WriteRecords(PacketWriter& writer, const std::vector<Record>& in){	for (auto& r : in)	{		writer.WriteLabels(r.rName);		writer.WriteUInt16(r.rType);		writer.WriteUInt16(r.rClass);		writer.WriteUInt32(r.rTTL);		writer.WriteUInt16(r.rDataLength);		writer.WriteByteArray(reinterpret_cast<const char*>(r.rData.data()), r.rData.size());	}}uint8_t SimpleDNSLogger::PacketReader::ReadUInt8(bool peek, size_t rpos){	uint8_t ret;	bool seekRead = true;	if (rpos == std::numeric_limits<size_t>::max())	{		seekRead = false;		rpos = pos;	}	if (sizeof(ret) + rpos > size)	{		throw std::out_of_range("read buffer underflow");	}	std::memcpy(&ret, &buffer[rpos], sizeof(ret));	if (!seekRead && !peek)	{		pos += sizeof(ret);	}	return ret;}uint16_t SimpleDNSLogger::PacketReader::ReadUInt16(bool peek, size_t rpos){	uint16_t ret;	bool seekRead = true;	if (rpos == std::numeric_limits<size_t>::max())	{		seekRead = false;		rpos = pos;	}	if (sizeof(ret) + rpos > size)	{		throw std::out_of_range("read buffer underflow");	}	std::memcpy(&ret, &buffer[rpos], sizeof(ret));	ret = ntohs(ret);	if (!seekRead && !peek)	{		pos += sizeof(ret);	}	return ret;}uint32_t SimpleDNSLogger::PacketReader::ReadUInt32(bool peek, size_t rpos){	uint32_t ret;	bool seekRead = true;	if (rpos == std::numeric_limits<size_t>::max())	{		seekRead = false;		rpos = pos;	}	if (sizeof(ret) + rpos > size)	{		throw std::out_of_range("read buffer underflow");	}	std::memcpy(&ret, &buffer[rpos], sizeof(ret));	ret = ntohl(ret);	if (!seekRead && !peek)	{		pos += sizeof(ret);	}	return ret;}const char* SimpleDNSLogger::PacketReader::ReadByteArray(size_t length, bool peek, size_t rpos){	const char* ret = nullptr;	bool seekRead = true;	if (rpos == std::numeric_limits<size_t>::max())	{		seekRead = false;		rpos = pos;	}	if (length + rpos > size)	{		throw std::out_of_range("read buffer underflow");	}	ret = &buffer[rpos];	if (!seekRead && !peek)	{		pos += length;	}	return ret;}void SimpleDNSLogger::PacketReader::ReadLabels(std::vector<std::string>& labels){	size_t offset = pos;	bool jumped = false;	uint8_t length;	size_t totalLength = 0;	while ((length = ReadUInt8(true, offset)))	{		if (totalLength > 255)			throw std::out_of_range("name total length is too long");		if ((buffer[offset] & 0b1100'0000) == 0b1100'0000)		{			if (jumped)				offset = ReadUInt16(true, offset);			else				offset = ReadUInt16();			totalLength += 2;			offset &= 0b0011'1111;			if (offset > size)				throw std::out_of_range("label pointer offset overflow");			jumped = true;			continue;		}		offset += sizeof(uint8_t);		if (!jumped)			pos += sizeof(uint8_t);		if (offset + length > size)			throw std::out_of_range("label length overflow");		labels.emplace_back(&buffer[offset], length);		std::transform(labels.back().begin(),		               labels.back().end(),		               labels.back().begin(),		               [](auto c) { return std::tolower(c); });		offset += length;		totalLength += 1;		totalLength += length;		if (!jumped)			pos += length;	}	if (!jumped)		pos += sizeof(uint8_t); // tail \0}void SimpleDNSLogger::PacketWriter::WriteUInt8(uint8_t data){	if (pos + sizeof(data) > size)	{		throw std::out_of_range("write buffer underflow");	}	std::memcpy(&buffer[pos], &data, sizeof(data));	pos += sizeof(data);}void SimpleDNSLogger::PacketWriter::WriteUInt16(uint16_t data){	if (pos + sizeof(data) > size)	{		throw std::out_of_range("write buffer underflow");	}	data = htons(data);	std::memcpy(&buffer[pos], &data, sizeof(data));	pos += sizeof(data);}void SimpleDNSLogger::PacketWriter::WriteUInt32(uint32_t data){	if (pos + sizeof(data) > size)	{		throw std::out_of_range("write buffer underflow");	}	data = htonl(data);	std::memcpy(&buffer[pos], &data, sizeof(data));	pos += sizeof(data);}void SimpleDNSLogger::PacketWriter::WriteByteArray(const char* buffer, size_t length){	if (pos + length > size)	{		throw std::out_of_range("write buffer underflow");	}	std::memcpy(&this->buffer[pos], buffer, length);	pos += length;}void SimpleDNSLogger::PacketWriter::WriteLabels(const std::vector<std::string>& labels){	auto iter = labels.begin();	size_t remain = labels.size();	LookupTableEntry entry;	entry.first = &labels;	while (iter != labels.end())	{		if (iter->size() > 63)		{			throw std::out_of_range("label length is too long");		}		if (iter->empty())		{			throw std::out_of_range("empty label");		}		for (auto& t : lut)		{			// find current labels in written labels' suffix			auto found = std::find(t.first->begin(), t.first->end(), *iter);			if (found != t.first->end())			{				if (std::distance(iter, labels.end()) == std::distance(found, t.first->end())					&& std::equal(iter, labels.end(), found))				{					auto offsetIter = t.second.begin();					std::advance(offsetIter, std::distance(t.first->begin(), found));					entry.second.insert(entry.second.end(), *offsetIter);					WriteUInt16(*offsetIter | 0b1100'0000'0000'0000);					lut.emplace_back(std::move(entry));					return;				}			}		}		// not found		// assume pos < 0b0011'1111'1111'1111		entry.second.push_back(static_cast<uint16_t>(pos));		WriteUInt8(static_cast<uint8_t>(iter->size()));		WriteByteArray(iter->data(), iter->size());		++iter;	}	WriteUInt8(0);	if (!entry.second.empty())		lut.emplace_back(std::move(entry));	return;}