#pragma once#include "Pch.h"namespace SimpleDNSLogger{    class PacketWriter;    class PacketReader;    class DnsServer    {    public:        static constexpr size_t BUFFER_SIZE = 512;        typedef std::function<void(const std::string& name, const std::string& ip)> Callback;    private:        typedef boost::array<char, BUFFER_SIZE> Buffer;        boost::asio::io_service ioService;        boost::asio::ip::udp::socket socket;        std::thread worker;        Callback callback;    public:        DnsServer();        ~DnsServer();        void SetListenPort(const std::string& address, unsigned short port);        void SetCallback(Callback&& procedure);        void Run(bool block = false);        void Stop();    private:        class Transaction        {        private:            DnsServer& server;            Buffer buffer;            boost::asio::ip::udp::endpoint peerEndpoint;            size_t replyLength;        public:            Transaction(DnsServer& server);            ~Transaction();            void WaitForSingleRequest(std::unique_ptr<Transaction>&& self);            void RequestHandler(std::unique_ptr<Transaction>&& self, size_t transferred);            void SendReply(std::unique_ptr<Transaction>&& self);        };        friend class Transaction;    private:        void WaitForSingleRequest();    };    class DnsPacket    {    public:        struct Query        {            std::vector<std::string> qName;            uint16_t qType;            uint16_t qClass;        };        struct Record        {            std::vector<std::string> rName;            uint16_t rType;            uint16_t rClass;            uint32_t rTTL;            uint16_t rDataLength;            std::vector<uint8_t> rData;        };    public:        uint16_t id;        uint16_t flags;        std::vector<Query> queries;        std::vector<Record> answers;        std::vector<Record> authorities;        std::vector<Record> additions;    public:        void FromBuffer(const char* buffer, size_t size);        size_t ToBuffer(char* buffer, size_t size) const;    public:        template <typename FLAG>        uint16_t GetFlag() const        {            return (flags >> FLAG::OFFSET) & FLAG::MASK;        }        template <typename FLAG>        void SetFlag(uint16_t value)        {            flags = ((value & FLAG::MASK) << FLAG::OFFSET) | (flags & ~(FLAG::MASK << FLAG::OFFSET));        }        // Flag fields definition        struct FLAG_QR        {            static constexpr size_t OFFSET = 15;            static constexpr uint16_t MASK = 0b1;        };        struct FLAG_OPCODE        {            static constexpr size_t OFFSET = 14;            static constexpr uint16_t MASK = 0b1111;            /*             * 0	Query	[RFC1035]             * 1    IQuery	(Inverse Query, OBSOLETE)	[RFC3425]             * 2	Status	[RFC1035]             * 3	Unassigned	             * 4	Notify	[RFC1996]             * 5	Update	[RFC2136]             * 6	DNS Stateful Operations (DSO)	[RFC8490]             * 7-15	Unassigned             */            static constexpr uint16_t Query = 0;        };        struct FLAG_AA        {            static constexpr size_t OFFSET = 10;            static constexpr uint16_t MASK = 0b1;        };        struct FLAG_TC        {            static constexpr size_t OFFSET = 9;            static constexpr uint16_t MASK = 0b1;        };        struct FLAG_RD        {            static constexpr size_t OFFSET = 8;            static constexpr uint16_t MASK = 0b1;        };        struct FLAG_RA        {            static constexpr size_t OFFSET = 7;            static constexpr uint16_t MASK = 0b1;        };        struct FLAG_Z        {            static constexpr size_t OFFSET = 4;            static constexpr uint16_t MASK = 0b111;        };        struct FLAG_RCODE        {            static constexpr size_t OFFSET = 0;            static constexpr uint16_t MASK = 0b1111;            static constexpr uint16_t NoError = 0;            static constexpr uint16_t ServFail = 2;            static constexpr uint16_t NXDomain = 3;        };    private:        static void ReadQueries(PacketReader& reader, size_t n, std::vector<Query>& out);        static void ReadRecords(PacketReader& reader, size_t n, std::vector<Record>& out);        static void WriteQueries(PacketWriter& writer, const std::vector<Query>& in);        static void WriteRecords(PacketWriter& writer, const std::vector<Record>& in);    };    class PacketReader    {    private:        const char* buffer;        size_t size;        size_t pos;    public:        PacketReader(const char* buffer, size_t size) :            buffer(buffer), size(size), pos(0)        {        }        uint8_t ReadUInt8(bool peek = false, size_t rpos = std::numeric_limits<size_t>::max());        uint16_t ReadUInt16(bool peek = false, size_t rpos = std::numeric_limits<size_t>::max());        uint32_t ReadUInt32(bool peek = false, size_t rpos = std::numeric_limits<size_t>::max());        const char* ReadByteArray(size_t length, bool peek = false, size_t rpos = std::numeric_limits<size_t>::max());        void ReadLabels(std::vector<std::string>& labels);    };    class PacketWriter    {    public:        typedef std::vector<std::string> LabelList;        typedef std::pair<const LabelList*, std::vector<uint16_t>> LookupTableEntry;        typedef std::vector<LookupTableEntry> LookupTable;    private:        char* buffer;        size_t size;        size_t pos;        LookupTable lut;    public:        PacketWriter(char* buffer, size_t size) :            buffer(buffer), size(size), pos(0)        {        }        size_t GetPos()const { return pos; }        void WriteUInt8(uint8_t data);        void WriteUInt16(uint16_t data);        void WriteUInt32(uint32_t data);        void WriteByteArray(const char* buffer, size_t length);        // be sure all references to written labels are valid before calling this        void WriteLabels(const std::vector<std::string>& labels);    };}