#pragma once#include "Pch.h"namespace SimpleDNSLogger{	class RpcHandler;	class MaxHandlerLimitReachedException : public std::runtime_error	{	public:		MaxHandlerLimitReachedException(): std::runtime_error("maximum handler limited reached!")		{		}	};	class ObserveHandler	{	private:		DNSLogger::AsyncService* service;		grpc::ServerCompletionQueue* cq;		grpc::ServerContext ctx;		grpc::ServerAsyncResponseWriter<ObservationResult> responder;		RpcHandler* rpcHandler;		std::mutex mutex;		int expectedCompletion;		ObservationRequest request;		ObservationResult result;		enum Status { New, Created, WaitForWitness, Witnessed, Done };		Status status = New;	public:		ObserveHandler(DNSLogger::AsyncService* service, grpc::ServerCompletionQueue* cq, RpcHandler* rpcHandler);		~ObserveHandler();		void UpdateStatus(bool ok, bool doneFlag);		void SetResult(const std::string& name, const std::string& ip);	};	class RpcHandler	{	public:		typedef std::function<void(const std::string& name, const std::string& ip)> ObserveCallback;	private:		std::unique_ptr<grpc::ServerCompletionQueue> srvCompleteQueue;		DNSLogger::AsyncService srvService;		std::unique_ptr<grpc::Server> srvServer;		std::thread srvThread;		std::atomic<bool> running = false;		std::unordered_set<std::string> authorizedPsk;		// AsyncOperationCollection		// note: the collection will be locked when add/cancel/fire an operation		std::unordered_map<std::string, ObserveCallback> observedNames;		std::mutex observedNamesMutex;	public:		RpcHandler();		~RpcHandler();		void StartServer(const std::string& address, unsigned short port);		void StopServer();		void CreateNewObserveHandler();		void WitnessDnsQuery(const std::string& name, const std::string& ip);		void AddPsk(const std::string& psk);		bool CheckPsk(const std::string& psk);		bool IsRunning()const { return running; }		/**		 * \brief Add a new observation (StartAsyncOperation)		 * \param name the full domain name string to be observed		 * \param callback the callback will be called after an witness		 * \return whether the observation request is added to list successfully.		 */		bool CreateObservation(const std::string& name, ObserveCallback&& callback);		/**		 * \brief Remove a observation before its callback is fired (CancelAsyncOperation).		 *	      After this method returns, the operation is guaranteed to be canceled or already fired.		 * \param name the full domain name string		 * \return whether the observation request is canceled		 */		bool CancelObservation(const std::string& name);	};}